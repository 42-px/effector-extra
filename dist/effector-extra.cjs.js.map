{"version":3,"file":"effector-extra.cjs.js","sources":["../src/attach-wrapper/index.ts","../src/effector-event-batcher/index.ts","../src/create-service/index.ts","../src/mocks/index.ts"],"sourcesContent":["import {\n    Effect, createEffect, Domain,\n} from \"effector\"\n\nexport function attachWrapper<AttachP, AttachD, AttachF, P, D, F>({\n    domain,\n    effect,\n    mapParams,\n    mapResult,\n    mapError,\n}: {\n  domain?: Domain\n  effect: Effect<P, D, F>\n  mapParams: (params: AttachP) => P\n  mapResult: ({ params, result }: { params: AttachP; result: D }) => AttachD\n  mapError: ({ params, error }: { params: AttachP; error: F }) => AttachF\n}): Effect<AttachP, AttachD, AttachF>\nexport function attachWrapper<AttachP, AttachD, P, D, F>({\n    domain,\n    effect,\n    mapParams,\n    mapResult,\n}: {\n  domain?: Domain\n  effect: Effect<P, D, F>\n  mapParams: (params: AttachP) => P\n  mapResult: ({ params, result }: { params: AttachP; result: D }) => AttachD\n}): Effect<AttachP, AttachD, F>\nexport function attachWrapper<AttachP, AttachF, P, D, F>({\n    domain,\n    effect,\n    mapParams,\n    mapError,\n}: {\n  domain?: Domain\n  effect: Effect<P, D, F>\n  mapParams: (params: AttachP) => P\n  mapError: ({ params, error }: { params: AttachP; error: F }) => AttachF\n}): Effect<AttachP, D, AttachF>\nexport function attachWrapper(args: any): any {\n    const handler = (params: any) => {\n        let promise: any = args.effect(args.mapParams(params))\n        if (args.mapResult) {\n            promise = promise.then(\n                (result: any) => args.mapResult({ params, result })\n            )\n        }\n        if (args.mapError) {\n            promise = promise.catch((error: any) => {\n                throw args.mapError({ params, error })\n            })\n        }\n        return promise\n    }\n\n\n    const effect =  args.domain\n        ? args.domain.effect()\n        : createEffect()\n    effect.use(handler)\n    return effect\n}\n","import {\n    createEvent,\n    createStore,\n    Event,\n    EventCallable,\n    guard,\n    sample,\n} from \"effector\"\n\nexport function batchEvents<T>(trigger: Event<T>, timeout: number): EventCallable<T[]> {\n    const event = createEvent<T[]>()\n    const pushStore = createEvent<T>()\n    const resetStore = createEvent()\n    const timeoutEnd = createEvent()\n    const $storedEvents = createStore<T[]>([])\n    $storedEvents\n        .on(pushStore, (prevValue, value) => [...prevValue, value])\n        .reset(resetStore)\n\n    let timeoutId: any\n    trigger.watch((payload) => {\n        if (timeoutId !== undefined) {\n            clearTimeout(timeoutId)\n            pushStore(payload)\n        } else {\n            event([payload])\n        }\n        timeoutId = setTimeout(() => {\n            timeoutId = undefined\n            timeoutEnd()\n        }, timeout)\n    })\n    guard({\n        source: sample({\n            source: $storedEvents,\n            clock: timeoutEnd,\n            fn: (store) => store,\n        }),\n        filter: $storedEvents.map((store) => Boolean(store.length)),\n    }).watch((payload) => {\n        event(payload)\n        resetStore()\n    })\n    return event\n}\n","import { Domain, Effect } from \"effector\"\nimport { attachWrapper } from \"../attach-wrapper\"\n\ntype Params<P, D, F> = {\n  domain: Domain\n  effect: Effect<P, D, F>\n}\n\nexport function createService<P, D, F>({ domain, effect }: Params<P, D, F>) {\n    function createMethod<AttachP, AttachD, AttachF>({\n        mapParams,\n        mapResult,\n        mapError,\n    }: {\n      mapParams: (params: AttachP) => P\n      mapResult: ({ params, result }: { params: AttachP; result: D }) => AttachD\n      mapError: ({ params, error }: { params: AttachP; error: F }) => AttachF\n    }): Effect<AttachP, AttachD, AttachF>\n    function createMethod<AttachP, AttachD>({\n        mapParams,\n        mapResult,\n    }: {\n      mapParams: (params: AttachP) => P\n      mapResult: ({ params, result }: { params: AttachP; result: D }) => AttachD\n    }): Effect<AttachP, AttachD, F>\n    function createMethod<AttachP, AttachF>({\n        mapParams,\n        mapError,\n    }: {\n      mapParams: (params: AttachP) => P\n      mapError: ({ params, error }: { params: AttachP; error: F }) => AttachF\n    }): Effect<AttachP, D, AttachF>\n    function createMethod(args: any): any {\n        return attachWrapper({ domain, effect, ...args })\n    }\n\n    return { createMethod }\n}\n","import { Effect, Store } from \"effector\"\n\ninterface EffectsMapper extends Map<any, any> {\n    set<P, D, E>(\n        effect: Effect<P, D, E>, handler: (params: P) => D | Promise<D>\n    ): this\n}\n\nexport const mockEffects = (): EffectsMapper => {\n    return new Map()\n}\n\ninterface StoreMapper extends Map<any, any> {\n  set<V>(store: Store<V>, value: V): this\n}\n\nexport const mockStores = (): StoreMapper => {\n    return new Map()\n}\n"],"names":["attachWrapper","args","effect","domain","name","sid","createEffect","use","params","promise","mapParams","mapResult","then","result","mapError","catch","error","trigger","timeout","event","createEvent","pushStore","resetStore","timeoutEnd","$storedEvents","createStore","timeoutId","on","prevValue","value","reset","watch","payload","undefined","clearTimeout","setTimeout","guard","and","source","sample","clock","fn","store","or","filter","map","Boolean","length","createMethod","_withFactory","\"7v5c9k\"","\"none\"","method","\"attachWrapper\"","mockEffects","Map","mockStores"],"mappings":"8FAuCM,SAAUA,EAAcC,GAC1B,MAgBMC,EAAUD,EAAKE,OACfF,EAAKE,OAAOD,OAAM,CAAAE,KAAA,SAAAC,IAAA,YAClBC,EAAAA,aAAY,CAAAF,KAAA,SAAAC,IAAA,YAElB,OADAH,EAAOK,KAnBUC,IACb,IAAIC,EAAeR,EAAKC,OAAOD,EAAKS,UAAUF,GAAO,CAAAJ,KAAA,UAAAC,IAAA,YAWrD,OAVIJ,EAAKU,YACLF,EAAUA,EAAQG,MACbC,GAAgBZ,EAAKU,UAAU,CAAEH,SAAQK,cAG9CZ,EAAKa,WACLL,EAAUA,EAAQM,OAAOC,IACrB,MAAMf,EAAKa,SAAS,CAAEN,SAAQQ,SAAQ,KAGvCP,CAAO,IAQXP,CACX,6CCpDgB,SAAee,EAAmBC,GAC9C,MAAMC,EAAQC,EAAAA,YAAW,CAAAhB,KAAA,QAAAC,IAAA,YACnBgB,EAAYD,EAAAA,YAAW,CAAAhB,KAAA,YAAAC,IAAA,YACvBiB,EAAaF,EAAAA,YAAW,CAAAhB,KAAA,aAAAC,IAAA,YACxBkB,EAAaH,EAAAA,YAAW,CAAAhB,KAAA,aAAAC,IAAA,YACxBmB,EAAgBC,EAAWA,YAAM,GAAE,CAAArB,KAAA,gBAAAC,IAAA,WAKzC,IAAIqB,EAwBJ,OA5BAF,EACKG,GAAGN,GAAW,CAACO,EAAWC,IAAU,IAAID,EAAWC,KACnDC,MAAMR,GAGXL,EAAQc,OAAOC,SACOC,IAAdP,GACAQ,aAAaR,GACbL,EAAUW,IAEVb,EAAM,CAACa,IAEXN,EAAYS,YAAW,KACnBT,OAAYO,EACZV,GAAY,GACbL,EAAQ,IAEfkB,QAAK,CAAAC,IAAC,CAAA,CACFC,OAAQC,EAAAA,OAAM,CAAAF,IAAC,CAAA,CACXC,OAAQd,EACRgB,MAAOjB,EACPkB,GAAKC,GAAUA,IAClBC,GAAA,CAAAvC,KAAA,SAAAC,IAAA,YACDuC,OAAQpB,EAAcqB,KAAKH,GAAUI,QAAQJ,EAAMK,YACtDJ,GAAA,CAAAtC,IAAA,YAAE0B,OAAOC,IACNb,EAAMa,GACNV,GAAY,IAETH,CACX,kCCpCuChB,OAAEA,EAAMD,OAAEA,IA4B7C,MAAO,CAAE8C,aAJT,SAAsB/C,GAClB,OAAAgD,cAAA,CAAA5C,IAAA6C,SAAAT,GAAAA,IAAOzC,EAAc,CAAEG,SAAQD,YAAWD,IAAOG,KAAA+C,OAAAC,OAAAC,iBACrD,EAGJ,sBC7B2BC,IAChB,IAAIC,uBAOWC,IACf,IAAID"}