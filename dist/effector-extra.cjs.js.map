{"version":3,"file":"effector-extra.cjs.js","sources":["../src/attach-wrapper/index.ts","../src/effector-event-batcher/index.ts","../src/mocks/index.ts","../src/create-service/index.ts"],"sourcesContent":["import {\n    Effect, createEffect, Domain,\n} from \"effector\"\n\nexport function attachWrapper<AttachP, AttachD, AttachF, P, D, F>({\n    domain,\n    effect,\n    mapParams,\n    mapResult,\n    mapError,\n}: {\n  domain?: Domain\n  effect: Effect<P, D, F>\n  mapParams: (params: AttachP) => P\n  mapResult: ({ params, result }: { params: AttachP; result: D }) => AttachD\n  mapError: ({ params, error }: { params: AttachP; error: F }) => AttachF\n}): Effect<AttachP, AttachD, AttachF>\nexport function attachWrapper<AttachP, AttachD, P, D, F>({\n    domain,\n    effect,\n    mapParams,\n    mapResult,\n}: {\n  domain?: Domain\n  effect: Effect<P, D, F>\n  mapParams: (params: AttachP) => P\n  mapResult: ({ params, result }: { params: AttachP; result: D }) => AttachD\n}): Effect<AttachP, AttachD, F>\nexport function attachWrapper<AttachP, AttachF, P, D, F>({\n    domain,\n    effect,\n    mapParams,\n    mapError,\n}: {\n  domain?: Domain\n  effect: Effect<P, D, F>\n  mapParams: (params: AttachP) => P\n  mapError: ({ params, error }: { params: AttachP; error: F }) => AttachF\n}): Effect<AttachP, D, AttachF>\nexport function attachWrapper(args: any): any {\n    const handler = (params: any) => {\n        let promise: any = args.effect(args.mapParams(params))\n        if (args.mapResult) {\n            promise = promise.then(\n                (result: any) => args.mapResult({ params, result })\n            )\n        }\n        if (args.mapError) {\n            promise = promise.catch((error: any) => {\n                throw args.mapError({ params, error })\n            })\n        }\n        return promise\n    }\n\n\n    const effect =  args.domain\n        ? args.domain.effect()\n        : createEffect()\n    effect.use(handler)\n    return effect\n}\n","import {\n    createEvent,\n    createStore,\n    Event,\n    guard,\n    sample,\n} from \"effector\"\n\nexport function batchEvents<T>(trigger: Event<T>, timeout: number): Event<T[]> {\n    const event = createEvent<T[]>()\n    const pushStore = createEvent<T>()\n    const resetStore = createEvent()\n    const timeoutEnd = createEvent()\n    const $storedEvents = createStore<T[]>([])\n    $storedEvents\n        .on(pushStore, (prevValue, value) => [...prevValue, value])\n        .reset(resetStore)\n\n    let timeoutId: any\n    trigger.watch((payload) => {\n        if (timeoutId !== undefined) {\n            clearTimeout(timeoutId)\n            pushStore(payload)\n        } else {\n            event([payload])\n        }\n        timeoutId = setTimeout(() => {\n            timeoutId = undefined\n            timeoutEnd()\n        }, timeout)\n    })\n    guard({\n        source: sample(\n            $storedEvents,\n            timeoutEnd,\n            (store) => store,\n        ),\n        filter: $storedEvents.map((store) => Boolean(store.length)),\n    }).watch((payload) => {\n        event(payload)\n        resetStore()\n    })\n    return event\n}\n","import { Effect, Store } from 'effector'\n\ninterface EffectsMapper extends Map<any, any> {\n    set<P, D, E>(effect: Effect<P, D, E>, handler: (params: P) => D | Promise<D>): this;\n}\n\nexport const mockEffects = (): EffectsMapper => {\n    return new Map()\n}\n\ninterface StoreMapper extends Map<any, any> {\n  set<V>(store: Store<V>, value: V): this;\n}\n\nexport const mockStores = (): StoreMapper => {\n  return new Map()\n}","import { Domain, Effect } from \"effector\"\nimport { attachWrapper } from \"../attach-wrapper\"\n\ntype Params<P, D, F> = {\n  domain: Domain\n  effect: Effect<P, D, F>\n}\n\nexport function createService<P, D, F>({ domain, effect }: Params<P, D, F>) {\n    function createMethod<AttachP, AttachD, AttachF>({\n        mapParams,\n        mapResult,\n        mapError,\n    }: {\n      mapParams: (params: AttachP) => P\n      mapResult: ({ params, result }: { params: AttachP; result: D }) => AttachD\n      mapError: ({ params, error }: { params: AttachP; error: F }) => AttachF\n    }): Effect<AttachP, AttachD, AttachF>\n    function createMethod<AttachP, AttachD>({\n        mapParams,\n        mapResult,\n    }: {\n      mapParams: (params: AttachP) => P\n      mapResult: ({ params, result }: { params: AttachP; result: D }) => AttachD\n    }): Effect<AttachP, AttachD, F>\n    function createMethod<AttachP, AttachF>({\n        mapParams,\n        mapError,\n    }: {\n      mapParams: (params: AttachP) => P\n      mapError: ({ params, error }: { params: AttachP; error: F }) => AttachF\n    }): Effect<AttachP, D, AttachF>\n    function createMethod(args: any): any {\n        return attachWrapper({ domain, effect, ...args })\n    }\n\n    return { createMethod }\n}\n"],"names":["attachWrapper","args","handler","params","promise","effect","mapParams","mapResult","then","result","mapError","error","domain","createEffect","use","batchEvents","trigger","timeout","event","createEvent","pushStore","resetStore","timeoutEnd","$storedEvents","createStore","on","prevValue","value","reset","timeoutId","watch","payload","undefined","clearTimeout","setTimeout","guard","source","sample","store","filter","map","Boolean","length","mockEffects","Map","mockStores","createService","createMethod"],"mappings":"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"}